<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Djangae by potatolondon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Djangae</h1>
      <h2 class="project-tagline">The best way to run Django on Google App Engine</h2>
      <a href="https://github.com/potatolondon/djangae" class="btn">View on GitHub</a>
      <a href="https://github.com/potatolondon/djangae/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/potatolondon/djangae/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="djangae" class="anchor" href="#djangae" aria-hidden="true"><span class="octicon octicon-link"></span></a>Djangae</h1>

<p><a href="http://travis-ci.org/potatolondon/djangae?branch=master"><img src="https://secure.travis-ci.org/potatolondon/djangae.png?branch=master" alt="build-status-image"></a></p>

<p>The best way to run Django on Google App Engine.</p>

<p>Djangae (djan-gee) is a Django app that allows you to run Django applications on Google App Engine, including (if you
want to) using Django's models with the App Engine Datastore as the underlying database.</p>

<p>Google Group: <a href="https://groups.google.com/forum/#!forum/djangae-users">https://groups.google.com/forum/#!forum/djangae-users</a></p>

<p>Website: <a href="https://potatolondon.github.io/djangae/">https://potatolondon.github.io/djangae/</a></p>

<p>GitHub: <a href="https://github.com/potatolondon/djangae">https://github.com/potatolondon/djangae</a></p>

<p><strong>Note: Djangae is under heavy development, stability is not guaranteed. A 1.0 release will happen when it's ready</strong></p>

<h2>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h2>

<ul>
<li>A WSGI middleware that provides a clean way via which your Django app is plugged into App Engine.</li>
<li>A hook to allow App Engine's deferred tasks and mapreduce handlers to run through the same environment.</li>
<li>The ability to use the Datastore as the database for Django's models.  See <strong>The Database Backend</strong> for details.
You can also use App Engine's NDB, or you can use Google Cloud SQL (via the standard django MySQL backend) instead of
or along side the Datastore. Or use all 3!</li>
<li>
<code>djangae.contrib.gauth</code> which provides user models (both concrete and extendable abstract versions), an auth backend, and a middleware; which allow you to authenticate users using the App Engine's built-in Google Accounts authentication, and also allow you to use Django's permissions system on the Datastore (i.e. without being caught out by the Many-To-Many relationships).</li>
<li>A <code>runserver</code> command which fires up the App Engine SDK to serve your app (while still using Django's code reloading).</li>
<li>The ability to run management commands locally or on the remote App Engine Datastore.</li>
<li>A <code>shell</code> command that correctly sets up the environment/database. (Note, we should support this set up for any
custom commands as well, see TODO.md).</li>
</ul>

<h2>
<a id="supported-django-versions" class="anchor" href="#supported-django-versions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supported Django Versions</h2>

<p>The intention is always to support the last two versions of Django, although older versions may work. Currently
Django 1.6 and 1.7 are supported. 1.8 support will come soon after it's released.</p>

<h1>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h1>

<p><strong>If you just want to get started on a fresh Django project, take a look at <a href="https://github.com/potatolondon/djangae-scaffold">djangae-scaffold</a></strong></p>

<ul>
<li>Create a Django project, add app.yaml to the root. Make sure Django 1.6+ is in your project and importable</li>
<li>Install Djangae into your project, make sure it's importable (you'll likely need to manipulate the path in manage.py and wsgi.py)</li>
<li>Add djangae to <code>INSTALLED_APPS</code>.</li>
<li>At the top of your settings, insert the following line: <code>from djangae.settings_base import *</code> - this sets up some
default settings.</li>
<li>
<p>In app.yaml add the following handlers:</p>

<div class="highlight highlight-yml"><pre><span class="pl-s">- <span class="pl-ent">url:</span> <span class="pl-s">/_ah/(mapreduce|queue|warmup).*</span></span>
  <span class="pl-s"><span class="pl-ent">script:</span> <span class="pl-s">YOUR_DJANGO_APP.wsgi.application</span></span>
  <span class="pl-s"><span class="pl-ent">login:</span> <span class="pl-s">admin</span></span>

<span class="pl-s">- <span class="pl-ent">url:</span> <span class="pl-s">/.*</span></span>
  <span class="pl-s"><span class="pl-ent">script:</span> <span class="pl-s">YOUR_DJANGO_APP.wsgi.application</span></span></pre></div>
</li>
<li>
<p>Make your manage.py look something like this:</p>

<div class="highlight highlight-python"><pre><span class="pl-k">if</span> <span class="pl-c1">__name__</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>__main__<span class="pl-pds">"</span></span>:
    os.environ.setdefault(<span class="pl-s"><span class="pl-pds">"</span>DJANGO_SETTINGS_MODULE<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>myapp.settings<span class="pl-pds">"</span></span>)

    <span class="pl-k">from</span> djangae.core.management <span class="pl-k">import</span> execute_from_command_line

    execute_from_command_line(sys.argv)</pre></div>
</li>
<li>
<p>Use the Djangae WSGI handler in your wsgi.py, something like</p>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> django.core.wsgi <span class="pl-k">import</span> get_wsgi_application

<span class="pl-k">from</span> djangae.wsgi <span class="pl-k">import</span> DjangaeApplication

application <span class="pl-k">=</span> DjangaeApplication(get_wsgi_application())</pre></div>
</li>
<li><p>Add the following to your URL handler: <code>url(r'^_ah/', include('djangae.urls'))</code></p></li>
<li><p>It is recommended that for improved security you add <code>djangae.contrib.security.middleware.AppEngineSecurityMiddleware</code> as the first
of your middleware classes. This middleware patches a number of insecure parts of the Python and App Engine libraries and warns if your
Django settings aren't as secure as they could be.</p></li>
<li>If you wish to use the App Engine's Google Accounts-based authentication to authenticate your users, and/or you wish to use Django's permissions system with the Datastore as you DB, then see the section on <strong>Authentication</strong>.</li>
<li><strong>It is highly recommended that you read the section on <a href="#unique-constraint-checking">Unique Constraints</a></strong></li>
</ul>

<h2>
<a id="deployment" class="anchor" href="#deployment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Deployment</h2>

<p>Create a Google App Engine project. Edit <code>app.yaml</code> and change <code>application: [...]</code> to <code>application: your-app-id</code>. Then run:</p>

<pre><code>$ appcfg.py update ./
</code></pre>

<p>If you have two-factor authentication enabled in your Google account, run:</p>

<pre><code>$ appcfg.py --oauth2 update ./
</code></pre>

<h2>
<a id="the-database-backend" class="anchor" href="#the-database-backend" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Database Backend</h2>

<p>Previously, in order to use Django's ORM with the App Engine Datastore, django-nonrel was required, along with
djangoappengine. That's now changed. With Djangae you can use vanilla Django with the Datastore. Heavily inspired by
djangoappengine (thanks Waldemar!) Djangae provides an intelligent database backend that allows vanilla Django to be
used, and makes use of many of the Datastore's speed and efficiency features such as projection queries.</p>

<p>Here's the full list of magic:</p>

<ul>
<li>Database-level enforcement of <code>unique</code> and <code>unique_together</code> constraints.</li>
<li>A transparent caching layer for queries which return a single result (<code>.get</code> or any query filtering on a unique field
or unique-together fields). This helps to avoid Datastore
<a href="https://developers.google.com/appengine/docs/python/datastore/structuring_for_strong_consistency">consistency issues</a>.</li>
<li>Automatic creation of additional index fields containing pre-manipulated values, so that queries such as <code>__iexact</code>
work out of the box. These index fields are created automatically when you use the queries.  Use
<code>settings.GENERATE_SPECIAL_INDEXES_DURING_TESTING</code> to control whether that automatic creation happens during tests.</li>
<li>Support for queries which weren't possible with djangoappengine, such as OR queries using <code>Q</code> objects.</li>
<li>A <code>ListField</code> which provides a "normal" django model field for storing lists (a feature of the Datastore).</li>
</ul>

<h2>
<a id="roadmap" class="anchor" href="#roadmap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Roadmap</h2>

<p>1.0-beta</p>

<ul>
<li>Support for ancestor queries. Lots of tests</li>
<li>All NotSupportedError tests being skipped, everything passes in the testapp</li>
<li>Namespaces handled via the connection settings</li>
</ul>

<h3>
<a id="what-cant-it-do" class="anchor" href="#what-cant-it-do" aria-hidden="true"><span class="octicon octicon-link"></span></a>What Can't It Do?</h3>

<p>Due to the limitations of the App Engine Datastore (it being a non-relational database for a start), there are some
things which you still can't do with the Django ORM when using the djangae backend.  The easiest way to find these out
is to just build your app and look out for the <code>NotSupportedError</code> exceptions.  But if you don't like surprises, here's
a quick list:</p>

<ul>
<li>
<code>ManyToManyField</code> - a non-relational database simply can't do these (or not efficiently).  However, you can probably
solve these kind of problems using djangae's <code>ListField</code>.  We may even create a many-to-many replacement based on
that in the future.</li>
<li>
<code>__in</code> queries with more than 30 values.  This is a limitation of the Datastore.  You can filter for up to 500 values
on the primary key field though.</li>
<li>More than one inequality filter, i.e. you can't do <code>.exclude(a=1, b=2)</code>.  This is a limitation of the Datastore.</li>
<li>Transactions.  The Datastore has transactions, but they are not "normal" transactions in the SQL sense. Transactions
should be done using <code>djangae.db.transactional.atomic</code>.</li>
</ul>

<h3>
<a id="other-considerations" class="anchor" href="#other-considerations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other Considerations</h3>

<p>When using the Datastore you should bear in mind its capabilities and limitations. While Djangae allows you to run
Django on the Datastore, it doesn't turn the Datastore into a relational database. There are things which the
datastore is good at (e.g. handling huge bandwidth of reads and writes) and things which it isn't good at
(e.g. counting). Djangae is not a substitute for knowing how to use the
<a href="https://developers.google.com/appengine/docs/python/datastore/">Datastore</a>.</p>

<h2>
<a id="localremote-management-commands" class="anchor" href="#localremote-management-commands" aria-hidden="true"><span class="octicon octicon-link"></span></a>Local/remote management commands</h2>

<p>If you set your manage.py up as described above, djangae will allow you to run management commands locally or
remotely, by specifying a <code>--sandbox</code>. Eg.</p>

<pre><code>  ./manage.py --sandbox=local shell   # Starts a shell locally (the default)
  ./manage.py --sandbox=remote shell  # Starts a shell using the remote datastore
</code></pre>

<p>With no arguments, management commands are run locally.</p>

<h2>
<a id="using-other-databases" class="anchor" href="#using-other-databases" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using other databases</h2>

<p>You can use Google Cloud SQL or sqlite (locally) instead of or along side the Datastore.</p>

<p>Note that the Database backend and settings for the Datastore remain the same whether you're in local development or on
App Engine Production, djangae switches between the SDK and the production datastore appropriately.  However, with
Cloud SQL you will need to switch the settings yourself, otherwise you could find yourself developing on your
live database!</p>

<p>Here's an example of how your <code>DATABASES</code> might look in settings.py if you're using both Cloud SQL and the Datastore.</p>

<div class="highlight highlight-python"><pre>    <span class="pl-k">from</span> djangae.utils <span class="pl-k">import</span> on_production

    DATABASES <span class="pl-k">=</span> {
        <span class="pl-s"><span class="pl-pds">'</span>default<span class="pl-pds">'</span></span>: {
            <span class="pl-s"><span class="pl-pds">'</span>ENGINE<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>djangae.db.backends.appengine<span class="pl-pds">'</span></span>
        }
    }

    <span class="pl-k">if</span> on_production():
        DATABASES[<span class="pl-s"><span class="pl-pds">'</span>sql<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> {
            <span class="pl-s"><span class="pl-pds">'</span>ENGINE<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>django.db.backends.mysql<span class="pl-pds">'</span></span>,
            <span class="pl-s"><span class="pl-pds">'</span>HOST<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>/cloudsql/YOUR_GOOGLE_CLOUD_PROJECT:YOUR_INSTANCE_NAME<span class="pl-pds">'</span></span>,
            <span class="pl-s"><span class="pl-pds">'</span>NAME<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>YOUR_DATABASE_NAME<span class="pl-pds">'</span></span>,
            <span class="pl-s"><span class="pl-pds">'</span>USER<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>root<span class="pl-pds">'</span></span>,
        }
    <span class="pl-k">else</span>:
        DATABASES[<span class="pl-s"><span class="pl-pds">'</span>sql<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> {
            <span class="pl-s"><span class="pl-pds">'</span>ENGINE<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>django.db.backends.sqlite3<span class="pl-pds">'</span></span>,
            <span class="pl-s"><span class="pl-pds">'</span>NAME<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>development.sqlite3<span class="pl-pds">'</span></span>
        }</pre></div>

<p>See the Google documentation for more information on connecting to Cloud SQL via the
<a href="https://developers.google.com/cloud-sql/docs/mysql-client">MySQL client</a> and from
<a href="https://developers.google.com/cloud-sql/docs/external">external applications</a>.</p>

<h2>
<a id="unique-constraint-checking" class="anchor" href="#unique-constraint-checking" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unique Constraint Checking</h2>

<p><strong>IMPORTANT: Make sure you read and understand this section before configuring your project</strong></p>

<p><em>tl;dr Constraint checking is costly, you might want to disable it globally using <code>settings.DJANGAE_DISABLE_CONSTRAINT_CHECKS</code> and re-enable on a per-model basis</em></p>

<p>Djangae by default enforces the unique constraints that you define on your models. It does so by creating so called "unique markers" in the datastore.
Unique constraint checks have the following caveats...</p>

<ul>
<li>Unique constraints drastically increase your datastore writes. Djangae needs to create a marker for each unique constraint on each model, for each instance. This means if you have
one unique field on your model, and you save() Djangae must do two datastore writes (one for the entity, one for the marker)</li>
<li>Unique constraints increase your datastore reads. Each time you save an object, Djangae needs to check for the existence of unique markers.</li>
<li>Unique constraints slow down your saves(). See above, each time you write a bunch of stuff needs to happen.</li>
<li>Updating instances via the datastore API (NDB, DB, or datastore.Put and friends) will break your unique constraints. Don't do that!</li>
<li>Updating instances via the datastore admin will do the same thing, you'll be bypassing the unique marker creation</li>
</ul>

<p>However, unique markers are very powerful when you need to enforce uniqueness. <strong>They are enabled by default</strong> simply because that's the behaviour that Django expects. If you don't want to
use this functionality, you have the following options:</p>

<ol>
<li>Don't mark fields as unique, or in the meta unique_together - this only works for your models, contrib models will still use unique markers</li>
<li>Disable unique constraints on a per-model basis via the Djangae meta class (again, only works on the model you specify)</li>
</ol>

<pre><code>    class Djangae:
        disable_constraint_checks = True
</code></pre>

<ol>
<li>Disable constraint checking globally via <code>settings.DJANGAE_DISABLE_CONSTRAINT_CHECKS</code>
</li>
</ol>

<p>The <code>disable_constraint_checks</code> per-model setting overrides the global <code>DJANGAE_DISABLE_CONSTRAINT_CHECKS</code> so if you are concerned about speed/cost then you might want to disable globally and
override on a per-model basis by setting <code>disable_constraint_checks = False</code> on models that require constraints.</p>

<h2>
<a id="datastore-caching" class="anchor" href="#datastore-caching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Datastore Caching</h2>

<p>Djangae has a built-in caching layer, similar to the one built into NDB - only better! You shouldn't even notice the caching layer at work, it's fairly complex and to understand the
behaviour you are best reading through the caching tests. But here's a general overview:</p>

<ul>
<li>There are two layers of caching, the context cache and the memcache cache</li>
<li>When possible, if you get/save an entity it will be cached by it's primary key value, and it's unique constraint combinations</li>
<li>This protects against HRD inconsistencies in many situations, and it happens automagically</li>
<li>The caching layer is heavily tied into the transaction.atomic decorator. If you use the db.RunInTransaction stuff you are going to have a hard time, so don't do that!</li>
<li>You can disable the caching by using the <code>disable_cache</code> context manager/decorator. <code>disable_cache</code> takes two boolean parameters, <code>context</code> and <code>memcache</code> so you can
configure which caches you want disabled. Be careful though, don't toggle the caching on and off too much or you might get into trouble (I'm sure there's a situation you can
break it but I haven't figured out what it is)</li>
<li>The context cache has a complex stack structure, when you enter a transaction the stack is pushed, and when you leave a transaction it's popped. This is to ensure the cache
gives you the right results at the right time</li>
<li>The context cache is cleared on each request, and it's thread-local</li>
<li>The memcache cache is not cleared, it's global across all instances and so is updated only when a consistent Get/Put outside a transaction is made</li>
<li>Entities are evicted from memcache if they are updated inside a transaction (to prevent crazy)</li>
</ul>

<p>The following settings are available to control the caching:</p>

<ul>
<li>DJANGAE_CACHE_ENABLED (default True). Setting to False it all off, I really wouldn't suggest doing that!</li>
<li>DJANGAE_CACHE_TIMEOUT_SECONDS (default 60 * 60). The length of time stuff should be kept in memcache.</li>
</ul>

<h2>
<a id="datastore-behaviours" class="anchor" href="#datastore-behaviours" aria-hidden="true"><span class="octicon octicon-link"></span></a>Datastore Behaviours</h2>

<p>The Djangae database backend for the Datastore contains some clever optimisations and integrity checks to make working with the Datastore easier.  This means that in some cases there are behaviours which are either not the same as the Django-on-SQL behaviour or not the same as the default Datastore behaviour. So for clarity, below is a list of statements which are true:</p>

<ul>
<li>Doing <code>MyModel.objects.create(primary_key_field=value)</code> will do an insert, so will explicitly check that an object with that PK doesn't already exist before inserting, and will raise an IntegrityError if it does. This is done in a transaction, so there is no need for any kind of manual transaction or existence checking.</li>
</ul>

<h2>
<a id="on-delete-constraints" class="anchor" href="#on-delete-constraints" aria-hidden="true"><span class="octicon octicon-link"></span></a>On Delete Constraints</h2>

<p>In general, django's emulation of SQL ON DELETE constraints works with djangae on the datastore. Due to eventual consistency however, the constraints can fail. Take care when deleting related objects in quick succession, a PROTECT constraint can wrongly cause a ProtectedError when deleting an object that references a recently deleted one. Constraints can also fail to raise an error if a referencing object was created just prior to deleting the referenced one. Similarly, when using ON CASCADE DELETE (the default behaviour), a newly created referencing object might not be deleted along with the referenced one.</p>

<h2>
<a id="contrib-applications" class="anchor" href="#contrib-applications" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contrib Applications</h2>

<ul>
<li><a href="djangae/contrib/gauth/README.md">Authentication with djangae.contrib.gauth</a></li>
<li><a href="djangae/contrib/mappers/README.md">Map-reduce integration with djangae.contrib.mappers</a></li>
<li><a href="djangae/contrib/pagination/README.md">Pagination with djangae.contrib.pagination</a></li>
</ul>

<h2>
<a id="testing" class="anchor" href="#testing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing</h2>

<p>For running the tests, you just need to run:</p>

<pre><code>$ ./runtests.sh
</code></pre>

<h2>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contributing</h2>

<p>Contributions are accepted via pull request and will be reviewed as soon as possible. If you have access to master, please do not commit directly! Pull requests only!</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/potatolondon/djangae">Djangae</a> is maintained by <a href="https://github.com/potatolondon">potatolondon</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-40029116-11");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>

